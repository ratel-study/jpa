# Jeff
JPA 스터디

---
# 05. 연관관계 매핑

ORM 에서 가장 어려운 부분

→ 객체의 참조와 외래키를 매핑하는 것이 핵심

- 방향.Direction
    - 단방향, 양방향
    - 객체관계에서만 방향이 존재 테이블 관계는 항상 양방향
- 다중성. Multiplicity
    - N:1 , 1:N, 1:1, N:N
- 연관관계의 주인
    - 양방향으로 만드는 경우 주인을 정해야 함

## 5.1 단방향 연관관계

- 회원과 팀
- 회원은 하나의 팀에만 소속
- 회원과 팀은 다대일 관계

객체 연관관계

- Member 에서 Team 객체를 필드로 연관관계
- 단방향 관계

테이블 연관관계

- 회원 테이블은 TEAM_ID 외래키로 테이블과 연관관계
- 양방향 관계

### 객체 vs 테이블

가장 큰 차이 : 단방향 vs 양방향

객체에도 양방향을 하려면 참조를 추가해야함

→ 단, 이것은 사실은 각 각이 단방향인 것

### 5.1.1 순순 객체에서의 연관 관계

Team을 setting 해서 사용 하는 예제

→ 객체 참조를 통해 연관관계 탐색

*⇒ 객체 그래프 탐색*

### 5.1.2 테이블 연관관계

외래키 설정 후 INSERT 시 외래키 매핑

→ 외래키를 통해 연관관계 탐색

⇒ JOIN

### 5.1.3 JPA를 통한 객체 관계 매핑

- @ManyToOne
    - N:1 다대일
    - Optional 연관된 엔티티 여부
    - fetch → 패치 전략 사용 → 8장
    - cascade → 영속성 전이 기능 사용 → 8장
- @JoinColumn(name=“TEAM_ID”)
    - 생략 가능
- @OneToMany
    - targetEntity=.class 로 설정 가능(그냥 제네릭 쓰자)

@ManyToOne , @OneToOne

## 5.2. 연관관계 사용

### 5.2.1 저장

→ 연관된 모든 엔티티는 영속상태여야함

→ 연관 관계의 id 를 적절히 가져가서 저장함

### 5.2.2 조회

조회 방법 크게 2가지

1. 객체 그래프 탐색(객체 연관관계를 사용한 조회)

   → 객체 참조

2. 객체지향 쿼리 JPQL 사용

   → 조인


### 5.2.3 수정

→ 기본적인 수정과 똑같다. 매핑되는 id 를 변경감지를 통해 변경

### 5.2.4 연관관계 제거

→ null로 셋팅하면 됨

### 5.2.5 연관된 엔티티 삭제

→ 연관관계를 제거하고 삭제하고 팀 삭제 해야함

→ FK 문제

## 5.3 양방향 연관관계

팀에서 회원 가도록 연관관계 추가

→ 양방향 되려면 컬렉션 구조로 가져야함

ex) Collection, Set, Map 등

디비는 이미 양방향이므로 추가할 내용이 없음

객체에만 상대 관계의 객체에

OneToMany 혹은 ManyToOne 추가하면 됨

MappedBy → 어떤 변수에 매핑하는건지 설정

## 5.4 연관관계의 주인

mappedBy 속성 왜 필요한가 ?

→ 객체의 연관관계는 양방향이라는 것이 없음

서로 단방향 2개이기 때문에 이를 논리적으로 묶어줘야 하기 때문

연관관계는 2개인데 외래키는 하나이기 때문에

누가 관계의 주인인지를 정해야 함

### 5.4.1 양방향 매핑의 규칙 : 연관관계의 주인

주인인 쪽에서만 외래키 관리(등록,수정,삭제) 가능

주인이 아닌쪽은 읽기만 가능

주인이 아닌쪽에서 mappedBy로 주인쪽 매핑

연관관계의 주인

→ 외래키를 가지고있는 쪽으로 정해야함

→ DB에서 다대일 일대다 에서는 항상 다 쪽에서 외래키를 가짐

→ @ManyToOne 에는 MappedBy 속성이 없음

## 5.5 양방향 연관관계 저장

단방향 저장하는 것과 완전히 동일

주인이 아닌쪽에서 설정하는 연관관계에 대한 정보는 반영되지 않음

## 5.6 양방향 연관관계의 주의점

가장 많은 실수 → 주인에 값을 입력하지 않고 주인이 아닌쪽에 값을 입력

⇒ 반영되지 않는다.(읽기 전용임)

### 5.6.1 순수한 객체까지 고려한 양방향 연관관계

한쪽만 입력하게 되면 JPA 를 사용하지 않는 순수 객체 상태에서는 문제 발생

→ 양쪽 다 셋팅해주는 것이 안전함

### 5.6.2 연관관계 편의 메서드

setTeam 같은 메서드 내부에 상대 연관관계에 요소를 추가하는 방법 등을 활용 할 수 있음

### 5.6.3 연관관계 편의 메서드 주의사항

setTeam 내부 상대 연관관계 매핑 할 때

Team 을 변경하는 경우에는 기존 Team 쪽의 Member 연관관계를 삭제해야함

→ 양방향 연관관계 관리하기 빡세다

- 단뱡향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료
- 단방향을 양방향으로 만드는 경우 반대방향 객체 그래프 탐색 가능
- 양방향 연관관계 매핑 시 객체에서 양방향 모두 관리

단방향을 우선적으로 사용하고 → 꼭 필요한 경우 양방향을 검토해보자

- 연관관계의 주인
    - 용어로 인한 오해로 비즈니스상 더 중요한 부분을 선택하면 안됨
    - 외래키 등록된을 주인으로

양방향에서 toString() 오버라이딩 하거나 무한루프에 빠질 수 있음 주의

→ 특히 JSON 변환 시에 자주 발생함 (어노테이션 사용해서 무시하거나 하는 방법 사용)

# 06. 다양한 연관관계 매핑

연관관계 매핑 시 고려 사항

1. 다중성
    1. 1:1 관계인지 1:N 관계인지
2. 단방향, 양방향
    1. 참조하는 방향
3. 연관관계의 주인
    1. 양방향인 경우 주인 정하기

## 다중성

- N:1
    - @ManyToOne
- 1:N
    - @OneToMany
- 1:1
    - @OneToOne
- N:N
    - @ManyToMany → 실무에서 사용 x

## 단방향, 양방향

→ 객체는 방향 설정(양방향도 결국 단방향 2개)

## 6.1 다대일

- 1:N 의 항상 반대

다대일 단방향, 다대일 양방향

→ 5장에서 다 했던 내용

## 6.2 일대다

- 1:N 단방향

  → 특이하게도 1쪽에서 외래키 관리

  → JoinColumn 명시해야함

    - 하지않으면 JPA에서 조인관계를 JoinTable 을 통해 관리함 → 7장
    - 단점
        - 매핑한 객체가 관리하는 외래키가 다른 테이블에 존재함
        - INSERT SQL 한번으로 안되고
            - INSERT 1회(연관관계 주인)
            - INSERT 1회(연관관계 대상) → 이 때 FK 반영안됨(모르기때문)
            - UPDATE 1회(PK 보관하는 N 쪽 테이블)

      → UPDATE가 추가로 생김


    ⇒ 일대다 단방향 보다는 다대일 양방향을 사용하자
    
    - 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래키를 관리해야하는 구조적인 문제가 있음
    - 성능 및 관리의 어려움
    - 일반적인 경우 다대일 양방향이 관리하기 더 나음

### 6.2.2 일대다 양방향

→ 다대일 양방향과 같은 의미임

일대다(연관관계 주인 기준으로) 양방향이란건 없음

강제로 N 쪽에 insertable, updatable 을 false 로 설정해서 할 수도 있음

→ 어거지이므로 이럴거면 그냥 다대일 양방향 쓰자

## 6.3. 일대일

특징

- 일대일 관계의 반대도 일대일 관계
- 테이블 관계에서 일대다, 다대일과 다르게
    - 일대일은 어느곳에서든 외래키 가질 수 있음

→ 일반적으로 주 테이블에서 관리되는 것을 선호

### 6.3.1 주테이블에 외래키

단방향

양방향

→ 특별할 건 없음

### 6.3.1 대상 테이블에 외래키

→ 일대일에서 대상테이블의 외래키 연관관계 매핑은

JPA 에서 지원하지 않음

→ 양방향으로 매핑해야함

- 프록시를 쓰는 경우 지연로딩이 안됨

  → 프록시의 한계 때문에 발생


<aside>
❓ 왜 ? 일대일 인 경우에만 이것이 작동을 하지 않을까?

→ 존재 여부의 불확실성
다대일의 경우는 참조의 존재가 보장 됨 ?

일대일인 경우는 왜 확인을 해야하는거지 ?

</aside>

## 6.4 다대다

테이블 구조에서는

→ 다대다 관계는 중간 테이블을 추가해서 매핑해서 관리해야함

객체는 다대다 구조가 가능함

### 6.4.1. 다대다 : 단방향

회원, 상품 관계

@ManyToMany , @JoinTable 사용하여 테이블을 바로 매핑

→ 중간 테이블을 설정함

@JoinTable.joinColumns : 현재 방향인 회원과 매핑할 조인 테이블 정보 (MEMBER_ID)

@JoinTable.inverseJoinColumns : 반대 방향인 상품과 매핑할 조인 정보(PRODUCT_ID)

### 6.4.2. 다대다 : 양방향

똑같음. ManyToMany 하고 mappedBy로 master 정하자(아닌 쪽이 mappedBy)

### 6.4.3 다대다 : 매핑의 한계와 극복, 연결 엔티티 사용

→ 실무에서는 중간 매핑 테이블에 담아야 하는 정보가 더 많음

→ 추가된 컬럼이 있으면 @ManyToMany 사용 불가

⇒ 테이블 구조와 동일하게 중간 객체 둬야함

그리고 중간 객체를 각 객체에서 OneToMany로 매핑

(한쪽은 안만들 수도 있음)

중간객체에서는 ManyToOne 으로 각각의 객체 매핑

@IdClass 로 복합 기본키 매핑 위한 식별자 클래스 생성 후 설정

(MemberId 와 ProductId 를 가지는 MemberProductId 클래스)

→ JPA에서 복합키 사용하려면 이렇게 해야함

- 별도의 식별자 클래스로 생성
- Serializable 구현
- equals & hashCode 재정의
- 기본 생성자
- public
- @IdClass 혹은 @Embeddable 사용 가능

부모 테이블의 기본 키를 받아서

자신의 기본 키 + 외래키로 사용 하는 것

→ 식별 관게 identifying Relationship

### 6.4.4 다대다 : 새로운 기본 키 사용

→ 복합키를 기본키로 사용하지 않고 대리키 값을 기본 키로 가져가고

→ 나머지는 참조로 사용하는 것

간편하고 비즈니스에 의존하지 않음

→ 비즈니스 관련 Key 를 PK로 하지 않는 것과 비슷한 논리

⇒ 비 식별 관계로 설계하는 것이 좋음

- 받아온 식별자는 외래키로만 사용하고 새로운 식별자 추가

→ 관리하기 편하고 단순하고 간편함
  getId에 있으면 → 접근자