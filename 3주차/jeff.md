# Jeff
JPA 스터디

---

# 08. 프록시

- 프록시
- 지연로딩
- 영속성 전이
- 고아 객체

## 프록시

→ 연관된 엔티티를 지연로딩 하기 위함

- 책에서 나오는 내용은 하이버네이트 기준

(바이트 코드를 사용하는 방법도 있으나 설정 복잡)

### 8.1.1 프록시 기초

- find()
    - 영속성 컨택스트에 없으면 DB 즉시 조회
- getReference()
    - 엔티티 실제 사용 지점까지 DB 조회 미룸
    - 프록시 객체 반환

프록시의 특징

→ 실제 클래스를 상속받아서 만들어짐(겉 모양이 같음)

→ 실제 객체에 대한 참조를 보관

- 처음 사용할 때 한번만 초기화
- 초기화 해도 여전히 프록시 객체임
- 타입 체크 시 주의해서 사용해야함
- 영속성 컨텍스트에 찾는 엔티티 이미 있으면 getReference 해도 실제 객체 반환
- 초기화는 영속성 컨텍스트의 도움을 받아야함
    
    → 준영속 상태의 프록시 초기화 하면 문제 발생
    
    (구현체 마다 다름)
    

프록시 동작 과정

1. 프록시 객체에 메서드를 호출해서 실제 데이터 조회
2. 실제 엔티티가 없으면 영속성 컨텍스트에 실제 엔티티 요청
    
    → 초기화
    
3. 영속성 컨택스트가 DB를 조회해서 실제 엔티티 객체 생성
4. 생성된 실제 엔티티 객체의 참조를 멤버변수에 보관
5. 프록시 객체는 실제 엔티티 객체의 메서드 호출해서 결과 반환

### 8.1.2 프록시와 식별자

- 프록시 조회 시 식별자(PK) 값을 파라미터로 전달함
    
    → 이 식별자 값을 보관함
    

- getId()를 호출해도 초기화 하지 않음
    
    → 엔티티 접근 방식이 PROPERTY인 경우에만
    
    → 필드 접근의 경우 getId()가 추가적인 동작을 하는 지 여부가 불확실하기에
    

→ 연관 관계 설정 시에는 필드 접근이여도 초기화 하지 않음

### 8.1.3 프록시 확인

```java
PersistenceUnitUtil.isLoaded(Obejct entity)

//하이버네이트 전용
org.hibernate.Hibernate.initialize() 로 강제 초기화 가능
```

를 사용하여 인스턴스 초기화 여부 확인 가능

## 8.2 즉시 로딩과 지연 로딩

### 즉시 로딩(EAGER LOADIN)

> 엔티티 조회할 때 연관된 엔티티 함께 조회
> 

fetch = FetchType.EAGER

→ 하이버네이트는 최대한 JOIN을 사용하여 조회함

<aside>
💡 NULL 제약조건과 JPA 조인 전략

외래키는 NULL이 허용이기 때문에 OUTLER JOIN을 사용함
최적화는 INNER JOIN이 유리하다

어떻게 INNER JOIN으로 만들지?
→ JoinColumn에 nullable =false 로 두면 INNER JOIN을 사용함

혹은 @ManyToOne 옵션에 optional = false 로 두면 됨

</aside>

### 지연 로딩(LAZY LOADING)

fetch = FetchType.LAZY

→ 어플리케이션 레벨에서 최적화에 관한 부분을 잘 판단해서 둘 중에 골라서 사용해야함

## 8.3 지연로딩 활용

### 8.3.1 프록시와 컬렉션 래퍼

→ 컬렉션 래퍼가 프록시 객체 역할 해줌

### 8.3.2 JPA 기본 페치 전략

- ManyToOne, OneToOne : 즉시 로딩
- OneToMany, ManyToMany : 지연로딩

연관된 엔티티가 하나면 즉시로딩, 컬렉션이면 지연로딩

**추천하는 방법 → 모든 연관관계에 지연 로딩 사용**

### 8.3.3 컬렉션 FetchType.EAGER 사용 시 주의

- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않음
    
    → 일대다 조인이기 때문에 여러 컬렉션은 N x M 의 데이터가 조회 되므로 성능 저하
    
- 컬렉션 즉시로딩은 항상 외부 조인 사용함
    - 일대다 관계를 조인 할 때는 → DB 제약조건으로 해결 불가능함
        
        ex) 소속한 멤버가 없는 팀이 조회가 안되는 상황이 발생함
        

## 8.4 영속성 전이 : CASCADE

- 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태 만드는 옵션

cascade = CascaedType.PERSIST

cascade = CascaedType.REMOVE

- ALL
- PERSIST
- MERGE
- REMOVE
- REFRESH
- DETACH

### 저장, 삭제 다 적용됨

## 8.5. 고아 객체

> 엔티티와 연관관계가 끊어진 자식 엔티티
> 

→ JPA에서 자동으로 삭제하는 기능 제공

- orphanRemoval = true

→ 특정 엔티티가 참조가 한 곳에서만 이루어질 때 가능

영속성 전이 + 고아 객체 , 생명 주기

→ CascadeType.ALL + orphanRemoval = true

: 생명주기를 부모 클래스에서 관리


# 09. 값 타입

### 엔티티 타입 vs 값 타입

엔티티 : @Entity로 정의하는 객체

값 : int, Integer, String 자바 기본 타입

## 기본 값 타입

공유 되지 않는 기본 값

## 임베디드 타입(복합 값 타입)

→ VO 같은 (ValueObject)

응집력 있게 변환 가능

@Embeddable → 값 타입을 정의하는 곳에 표시

@Embedded → 값 타입을 사용하는 곳에 표시

UML로 표현 하면 → Composition 관계가 됨

→ DB 값과 매핑은 값이기 때문에 나열된 것과 같음

### @AttributeOverride

> 임베디드 타입에 정의한 매핑 정보를 재정의
> 

ex) 집 주소에 회사 주소가 추가되는 경우

→ 회사 주소쪽에 @AttributeOverrid로 컬럼 매핑

임베디드 타입이 null이면 매핑한 컬럼 모두 null

## 9.3 값 타입과 불변 객체

값 타입 → 단순하고 안전하게 다룰 수 있어야 함

같은 값 타입을 여러 엔티티에서 공유하면 위험함

→ 불변으로 설계

→ 복사해서 사용

## 9.4 값 타입의 비교

equals(), hashCode() 재정의 해야함

## 9.5 값 타입 컬렉션

@ElementCollection

@CollectionTable

→ 테이블을 임의로 생성함

### 9.5.2 값 타입 컬렉션의 제약사항

- 식별자가 없음
    - 원본 데이터 쉽게 찾아서 변경 불가
- 값 타입 컬렉션의 값은 → 별도 테이블에서 보관
    - 값 타입의 값이 변경되면 DB에 있는 원본 데이터 찾기 어려움
    
    JPA에서는 변경이 일어나면 
    
    → 값 타입 컬렉션에 포함된 모든 데이터 삭제
    
    → 현재 값 타입 컬렉션 객체의 모든 값을 다시 저장
    

→ 이런 문제들은 해결하기 위해 일대다 관계로 엔티티 연관 관계 생성하면 됨

- + 영속성 전이, 고아객체 제거 기능 적용하면 값 타입 컬렉션과 동일하게 사용 가능
