# Peter
JPA 스터디

---
## Ch. 1. JPA 소개

1. **SQL을 직접 다룰 때 발생하는 문제점** 
   1. 반복 작업
   2. SQL 의존적 개발
   3. 계층 분리 어려움 - SQL을 확인해야 함

   
2. **패러다임의 불일치**
   1. 객체지향, 관계형 데이터베이스의 패러다임 불일치
      1. 상속
      2. 연관관계
         - 참조 - 외래키
      3. 객체 그래프 탐색
         - 한 번에 필요한 데이터 모두 조회해야 함
      4. 비교
         - 객체의 동일성 비교(==)   


3. **JPA?**
   - 애플리케이션-JDBC 사이에서 동작
   - JPA 장점
     - 생산성 향상
     - 유지보수 용이
     - 패러다임 불일치 해결
     - 성능
     - 데이터 접근 추상화, 벤더 독립성


---
## Ch. 3. 영속성 관리

1. **엔티티 매니저 팩토리와 엔티티 매니저**
   1. 엔티티 매니저 팩토리는 thread-safe, 엔티티 매니저는 아님
   2. 엔티티 매니저는 꼭 필요한 시점에 DB커넥션을 얻는다 


2. **영속성 컨텍스트?**
    - 엔티티를 영구 저장하는 환경
    - 엔티티 매니저를 생성할 때 하나 만들어짐
    - 매니저 당 하나의 영속성. But 여러 매니저가 같은 영속성에 접근할 수도 있음(Ch.11)


3. **엔티티의 생명주기**
    - 비영속 new, transient: 영속성 컨텍스트와 관계가 없는 상태
    - 영속 managed : 영속성 컨텍스트에 저장된 상태
    - 준영속 detached : 영속성 컨텍스트에 저장되었다가 분리된 상태 
    - 삭제 removed : 삭제된 상태


4. **영속성 컨텍스트의 특징**
   - 영속성 컨텍스트와 식별자 값
     - 엔티티를 식별자 값(@Id)으로 구분. 영속 상태는 식별자 값이 없으면 예외 발생
   - 영속성 컨텍스트와 데이터베이스 저장
     - 트랜잭션을 커밋하는 순간 (flush)
   - 장점
     - 1차 캐시
     - 동일성 보장
     - 트랜잭션을 지원하는 쓰기 지연
     - 변경 감지
     - 지연 로딩
   1. 엔티티 조회
      - 1차 캐시 : 영속성 컨텍스트 내부에 (식별자, 엔티티 인스턴스) 형태의 Map
      - em.find() : 1차 캐시에서 찾고, 없으면 DB조회
      - *JPA는 1차 캐시를 통해 애플리케이션 수준에서의 Repeatable Read 트랜잭션 격리 수준 제공
   2. 엔티티 등록
      - 트랜잭션을 커밋할 때 모아둔 쿼리를 DB로 보냄
      - 쓰기 지연 SQL 저장소에 쿼리를 모아둠
   3. 엔티티 수정
      - 변경 감지 dirty checking
      - 스냅샷 : 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둠
      - flush()가 호출 되면 엔티티와 스냅샷을 비교해 수정쿼리를 SQL 저장소에 보냄
      - 그 후 저장소의 SQL을 DB에 보냄
      - 변경 감지는 영속 상태의 엔티티에만 적용
      - 변경 감지로 인한 업데이트는 모든 필드에 대해 일어남
        - DynamicUpdate 어노테이션으로 동적으로 쿼리 생성 가능함(컬럼 30개쯤이 손익분기)
   4. 엔티티 삭제
      - 조회 후 em.remove(entity). 영속성 컨텍스트에서 즉시 제거 됨


5. **플러시**
    - 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
    - 플러시 하는 방법 3가지
      1. em.flush() 호출
      2. 트랜잭션 커밋 시 자동 호출
      3. JPQL 쿼리 실행시 자동 호출 
         - flush 하지 않으면 영속성 컨텍스트와 DB가 다르기 때문에
    - 플러시 모드 옵션
      - AUTO : 커밋이나 쿼리를 실행할 때 플러시 (default)
      - COMMIT : 커밋할 때만 플러시


6. **준영속**
    - 영속 -> 준영속
      1. em.detach(entity) : 특정 엔티티를 준영속 상태로
      2. em.clear() : 영속성 컨텍스트를 완전히 초기화
      3. em.close() : 영속성 컨텍스트를 종료
   - detach()
     - 1차 캐시, 쓰기 지연 저장소에서 해당 엔티티 관리 정보 삭제
   - clear()
     - 해당 영속성 컨텍스트의 모든 엔티티 준영속 상태로
   - clean()
     - 해당 영속성 컨텍스트가 관리하던 모든 영속 상태의 엔티티 준영속 상태로
   - 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않음
   - 식별자 값을 가지고 있음
   - 준영속, 비영속 -> 영속 : merge()
     - 식별자로 영속성 컨텍스트 조회


---
## Ch. 4. 엔티티 매핑

1. **@Entity**
   - 테이블과 매핑할 클래스에 사용
   - 기본 생성자 필요
   - final 클래스, enum, interface, inner 클래스에는 사용 불가
   - 저장할 필드에 final 사용 안 됨


2. **@Table**
    - 엔티티와 매핑할 테이블 지정


3. **다양한 매핑 사용**
    - @Enumerated : enum 사용
    - @Temporal : 자바 날짜 타입 매핑
    - @Lob : CLOB, BLOB 타입 매핑 (Character Large Object, Binary Large Object)


4. **데이터베이스 스키마 자동 생성**
    - 매핑정보를 활용하여 생성. 데이터베이스에 따른 차이(방언) 적용
    - 운영 환경에는 부적절함
    - 카멜 - 스네이크 매핑 전략 설정으로 가능


5. **DDL 생성 기능** 
    - 어노테이션, 어노테이션의 옵션을 통해 제약조건 추가 가능
      - DDL에만 영향을 주고, JPA 동작에는 영향 없음


6. **기본 키 매핑**
   - 직접 할당 : 애플리케이션에서 직접 할당
   - 자동 생성
     - IDENTITY : 데이터베이스에 위임
       - DB에 INSERT 후에 식별자를 알 수 있으므로 '트랜잭션을 지원하는 쓰기 지연'이 동작하지 않고 즉시 DB에 전달 됨
     - SEQUENCE : 데이터베이스 시퀀스 사용 
       - @SequenceGenerator
     - TABLE : 키 생성 테이블 사용
       - @TableGenerator
     - AUTO : 데이터베이스에 따라 세가지 중 자동으로 선택


7. **필드와 컬럼 매핑: 레퍼런스**
   - @Column
     - nullable = true 가 기본 값이므로 자바 기본 타입 사용시 주의
   - @Enumerated
     - EnumType.ORDINAL 이 기본 값. 주의 필요
   - @Temporal
   - @Lob
   - @Transient
     - 해당 필드는 매핑하지 않는다
   - @Access : JPA가 엔티티 데이터에 접근하는 방식
     - AccessType.FIELD : 필드에 직접 접근
     - AccessType.PROPERTY : 접근자 사용
     - @Access 사용하지 않을 시 @Id의 위치에 따라 설정 됨.

